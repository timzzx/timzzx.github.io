<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unix on 淡淡忧愁</title>
    <link>https://timx.cn/categories/unix/</link>
    <description>Recent content in Unix on 淡淡忧愁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Aug 2018 17:41:14 +0800</lastBuildDate>
    
	<atom:link href="https://timx.cn/categories/unix/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unix编程艺术(六)</title>
      <link>https://timx.cn/post/unix_art_6/</link>
      <pubDate>Tue, 07 Aug 2018 17:41:14 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_6/</guid>
      <description> Unix环境下的用户接口设计模式  在Unix接口设计的传统中，涉足两个主题。一个与其他程序通讯方式的前瞻性设计；另一个是最小立异原则
 最小立异原则  最小立异原则：“少来标新立异”是所有设计中的通用原则，且并非仅局限于软件设计。
如果有可能，尽量允许用户将接口功能委派给熟悉的程序来完成。
不能委派，那就效仿。目的减少用户在使用时必须学习的复杂过程。
 接口设计评估  简洁、表现力、易用、透明和脚本化能力。&amp;nbsp;能自动完成重复的任务
 Unix接口设计模式  1.过滤器模式 过滤器程序接受标准输入的数据，转换成某种格式后，再将结果发送到标准输出端。过滤器不是交互的，也许会查询启动环境，并且通常由命令行选项控制，但是并不要求用户在输入流中输入命令或给出反馈。
例子grep(1)
定义过滤器的原则 牢记Postel原则：宽进严出。 过滤时，不需要的信息也决不丢弃。 在过滤时，绝不增加无用数据。  2.Cantrip模式 没有输入，没有输出，只被调用一次，产生退出状态数值。程序只能由启动条件控制，程序非常具有脚本能力。
例子clear(1) 3.源模式
类似过滤器程序，不需要输入，它的输出只能在启动条件中控制。
例子ls(1)、ps(1)、who(1)
4.接收器模式
类似过滤器程序，只接纳标准输入而不发送任何东西到标准输出。它对输入端数据的作用行为只能在启动条件中控制。（这种用的比较少） 例子mail(1)
5.编译器模式
类似编译器程序既无标准输出也无标准输入，它们会将错误信息发送到标准错误端。
6.ed模式
最简单的交互设计模式
例子gdb(1)
7.Roguelike模式
一种游戏发展而来的模式
例子vi
8.“引擎和接口分离”模式
MVC模式
9.CLI服务器模式
类似PHP
10.基于语言的接口模式
配置（微语言）模式
 多价程序模式  多价程序（polyvalent，多角色程序）特征  程序的应用定义域逻辑封存在一个文档化的API库中，该库可被其它程序链接。程序同外部的接口逻辑是一个基于库的薄胶合层。或者有几个不同风格的UI层，每一个层都可以链接该库。 一种UI方式是cantrip，类似编译器或以批处理方式执行交互命令的CLI模式。 一种UI方式是GUI，可直接链接到核心库，或者作为一个独立进程来驱动CLI接口。 一种UI方式是脚本接口，使用现代的通用脚本语言，如Perl、Python或Tcl。 额外可选的一种UI方式是使用curses(3)的roguelike式接口。   </description>
    </item>
    
    <item>
      <title>Unix编程艺术(五)</title>
      <link>https://timx.cn/post/unix_art_5/</link>
      <pubDate>Mon, 06 Aug 2018 15:00:31 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_5/</guid>
      <description> Unix配置  经验法则： 提高适应能力，除非这样做会产生超过0.7秒的延迟。0.7秒是一个魔数，人们几乎察觉不到少于0.7秒的启动延迟。 用户不应该看到优化开关。让程序经济运行时设计者的任务，不是用户的任务。与提高界面复杂度成本相比，让用户从优化开关来获取那点儿性能收益，换来界面复杂度的提升，往往得不偿失。 能用脚本包装器或简单管道实现的任务，就不要用配置开关实现。能简单利用其它程序来完成的任务，就不要增加本程序的复杂度。    增加配置是要考虑的问题： 能省掉这个功能吗？为什么在加厚手册之外还要加重用户负担？ 能否用某种无伤大雅的方式改变程序的常规行为从而无需这个选项？ 这个选项是否花哨没用？是否应该少考虑用户界面的可配置性而多考虑正确性？ 这个选项附加的行为是否应该用一个独立的程序来代替？  增加不必要的选项会产生很多不良后果。其中最严重的后果是对测试覆盖率的影响。
 unix命令行选项    &amp;nbsp;&amp;nbsp;参数 说明     -a all : 全部，所有 (ls , lsattr , uname) archive : 存档 (cp , rsync) append : 附加 (tar -A , 7z)   -b blocksize : 块大小，带参数 (du , df) batch : 批处理模式 (交互模式的程序通常拥有此选项，如 top -b)   -c commands : 执行命令，带参数 (bash , ksh , python) create : 创建 (tar)   -d debug : 调试 delete : 删除 directory : 目录 (ls)   -e execute : 执行，带参数 (xterm , perl) edit : 编辑 exclude : 排除   -f force : 强制，不经确认(cp , rm ,mv) file : 文件，带参数 (tar) configuration file : 指定配置文件(有些守护进程拥有此选项，如 ssh , lighttpd)   -g    -h &amp;ndash;help : 帮助 human readable : 人性化显示(ls , du , df) headers : 头部   -i interactive : 交互模式，提示(rm , mv) include : 包含   -k keep : 保留 kill   -l long listing format : 长格式(ls) list : 列表 load : 读取 (gcc , emacs)   -m message : 消息 (cvs) manual : 手册 (whereis) create home : 创建 home 目录 (usermod , useradd)   -n number : 行号、编号 (cat , head , tail , pstree , lspci) no : (useradd , make)   -o output : 输出 (cc , sort) options : 选项 (mount)   -p port : 端口，带参数 (很多网络工具拥有此选项，如 ssh , lftp ) protocol : 协议，带参数 passwd : 密码，带参数   -q quiet : 静默   -r reverse : 反转 recursive : 递归 (cp , rm , chmod -R)   -s silent : 安静 size : 大小，带参数 subject   -t tag type : 类型 (mount)   -u user : 用户名、UID，带参数   -v verbose : 冗长 version : 版本   -w width : 宽度 warning : 警告   -x exclude : 排除 (tar , zip)   -y yes   -z zip : 启用压缩 (bzip , tar , zcat , zip , cvs)    </description>
    </item>
    
    <item>
      <title>Unix编程艺术(四)</title>
      <link>https://timx.cn/post/unix_art_4/</link>
      <pubDate>Sat, 04 Aug 2018 15:08:20 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_4/</guid>
      <description> 多道程序设计：分离进程为独立的功能  实现子进程方式： 降低进程生成的开销。 提供方法（shellout、I/O重定向、管道、消息传递和套接字）简化进程间通信。 提倡使用能由管道和套接字传递的简单、透明的文本数据格式。   UNIX IPC 方法的分类 把任务转给专门的程序 管道、重定向和过滤器  管道依赖的约定，每个程序一开始有两个I/O数据流可用：标准输入和标准输出。许多程序都可写作过滤器，从标准输入顺序读取数据，并且只向标准输出写数据。
 包装器 安全性包装器和Bernstein链 从进程 对等进程间通信   临时文件 最古老的IPC技法。 信号 Unix的信号是一种软终端形式：每个信号都对接收进程产生默认作用。 系统守护程序和常规信号 套接字 封装网络数据访问的方法 共享内存   要避免的问题和方法 废弃的UnixIPC方法 远程过程调用 线程——恐吓或威胁  线程增加了复杂度，线程程序可移植性差
 在设计层次上的进程划分  第一个要注意的是，临时文件、交互性更强的主/从进程关系、套接字、RPC和其它一些双向IPC方法在某种程度上是等价的——————它们都只不过是程序在生命期内交换程序的方法。我们通过使用套接字或共享内存在这种复杂方法所完成的任务，大多数都可以通过使用临时文件作为信箱和通知信号这种简单的方法来完成。差别很小，主要体现在程序如何建立通信、何时何地完成信息的列集和散集、可能产生何种缓冲问题，以及如何保证获取信息的原子性。
 </description>
    </item>
    
    <item>
      <title>Unix编程艺术(三)</title>
      <link>https://timx.cn/post/unix_art_3/</link>
      <pubDate>Fri, 03 Aug 2018 15:08:36 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_3/</guid>
      <description> 文本化  设计将应用数据存储在永久存储器中的文件格式在协作程序中（可能通过网络）传递数据和命令的应用协议
 数据文件元格式  为了简化存储的序列化操作发展得来。 DSV风格
RFC822格式
Cookie—Jar格式
Record—Jar格式
XML
WindowsINI格式
Unix文本文件格式的约定
 应用协议元格式  简化网络间事物处理的序列化操作发展得来。 HTTP
BEEP
XML—RPC，SOAP和Jabber
 透明性 为透明性和可显性而编码   程序调用层次中最大的静态深度是多少？也就是说，不考虑递归，为了建立心理模型来理解代码的操作，人们将要调用多少层？如果大于四层，就要当心。 代码是否具有强大、明显的不变性质？不变性质帮助人们推演代码和发现有问题的情况。 每个API中的各个函数调用是否正交？或者是否存在太多特征标志和模式位，使得一个调用要完成多个任务？完全避免模式标志会导致混乱的API，里面包括太多几乎一模一样的函数，但是频繁使用模式标志更容易产错误（很多易忘并且易混的模式标记）。 是否存在一些顺手可用的关键数据结构或全局唯一的记录器，捕获了系统的高层级状态？这个状态是否容易被形象化和检验，还是分布在数目众多的各个全局变量或对象中，而难以找到？ 程序的数据结构或分类和它们所代表的外部实体之间，是否存在清晰的一对一映射？ 是否容易找到给定函数的代码部分？不仅单个函数、模块、还有整个代码，需要花多少精力才能读懂？ 代码增加了特殊情况还是避免了特殊情况？每一个特殊情况可能对任何其他特殊情况产生影响；所有隐含的冲突都是BUG滋生的温床。然而更重要的是，特殊情况使得代码更难理解。 代码中有多少（意义含糊的常量）？通过审查是否很容易查出实现代码中的限制（比如关键缓冲区的大小）？   透明性和避免过度保护  调试和探测开关的存在是良好程序的标志
 </description>
    </item>
    
    <item>
      <title>Unix编程艺术(二)</title>
      <link>https://timx.cn/post/unix_art_2/</link>
      <pubDate>Fri, 03 Aug 2018 10:20:36 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_2/</guid>
      <description> 模块性  保持清晰，保持简洁
Unix 重视模块化、正交性和紧凑性问题。
 封装与最佳模块大小   封装良好的模块不会过多的向外部暴露自身的细节，不会直接调用其他模块的实现码，也不会胡乱共享全局数据。 模块之间通过应用程序编写的接口（API）— 一组严密、定义良好的程序调用和数据结构来通信。 API在模块间扮演双重角色。在实现层面，作为模块间的滞塞点组织各自的内部细节被相邻模块知晓；在设计层面，API真正定义了整个体系。 模块最佳的物理行数在400-800行。   紧凑性  一个设计是否能装进人脑中的特性紧凑也不意味着“小巧”。即使一个设计良好的系统，对有经验的用户来说没什么特异之处、“一眼”就能看懂，但仍然可能包含很多部分。—Ken Arnold
 正交性  只做好一件事。纯粹的正交设计中，任何操作均无副作用：每个动作只改变一件事，不会影响其他。
 SPOT原则  Don&amp;rsquo;t Repeat Yourself !任何一个知识点在系统内都应当有一个唯一、明确、权威的表述。这个原则也叫“真理的单点性（Single Point of Truth）”或者SPOT原则。
 软件层次设计  自底向上从具体到抽象，从问题确定具体操作向上进行。
  自顶向下从抽象到具体，从最高层面描述整个项目的规格说明或应用逻辑开始，向下进行，直到各个具体操作。
 模块式编码 以下问题，有助于提高代码的模块性
  有多少全局变量  全局变量对模块化是毒药，很容易使各模块轻率、混乱的互相泄露信息  单个模块的大小是否在“最佳范围”内？  “不，很多都超过”，就可能产生长期的维护问题。 不知道自己或合作者的最佳范围是多少，那么保持最佳范围的下限-400行。  模块内的单个函数是不是太大了？  与其说这是一个行数问题，不如说是一个内部复杂度问题。如果不能用一句话来简单描述一个函数与其调用程序之间的约定，这个函数可能太大了.  代码是不是有内部API 可作为单元向其他人描述的函数调用集合数据结构集，并且每个单元都封装某一层次函数，不受其他代码的影响？ API的入口点是不是超过七个？有没有类有七个以上的方法？数据结构的成员是不是超过七个？ 整个项目中每个模块的入口点数量如何分布？是不是不均匀？   </description>
    </item>
    
    <item>
      <title>Unix编程艺术(一)</title>
      <link>https://timx.cn/post/unix_art_1/</link>
      <pubDate>Thu, 02 Aug 2018 16:47:52 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_1/</guid>
      <description>UNIX哲学   原则1：你无法判断程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急与胡乱这个地方改代码，除非你已经证实那儿就是瓶颈所在。 原则2：估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。 原则3：花哨的算法在n很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑原则2）。 原则4：花哨的算法比简单算法更容易出bug、更难实现。尽量使用简单的算法配合简单的数据结构。（拿不准就穷举） 原则5：数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法。 原则6：没有原则6。   从整体来说，可以概括为：   模块原则：使用简洁的接口拼合简单的部件。 清晰原则：清晰胜于机巧。 组合原则：设计时考虑拼接组合。 分离原则：策略同机制分离，接口同引擎分离。 简洁原则：设计要简洁，复杂度能低则低。 吝啬原则：除非确无它法，不要编写庞大的程序。 透明性原则：设计要可见，以便审查和调试。 健壮原则：健壮源于透明与简洁。 表示原则：把知识叠入数据以求逻辑质朴而健壮。 通俗原则：接口设计避免标新立异。 缄默原则：如果一个程序没什么好说的，就沉默。 补救原则：出现异常时，马上退出并给出足够错误信息。 经济原则：宁花机器一分，不花程序员一秒。 生成原则：避免手工hack，尽量编写程序去生成程序。 优化原则：雕琢前先要有原型，跑之前先学会走。 多样原则：决不相信所谓“不二法门”的断言。 扩展原则：设计着眼未来，未来总比预想来得快。   UNIX “KISS” 原则  Keep It Simple , Stupid ! 简单就是美 !
 应用哲学   只要可行，一切都应该做成与来源和目标无关的过滤器。 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）。 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）。 复杂的前端（用户界面）和后端应该泾渭分明。 如果可能，用C编写前，先用解释性语言搭建原型。 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。 宽收严发（对接收的东西要包容，对输出的东西要严格）。 过滤时，不需要丢弃的信息决不丢。 小就是美。在确保完成任务的基础上，程序功能尽可能少。   Unix哲学与其他哲学的比较 不同的操作系统相关的设计和编程风格可以追溯的三个源头   操作系统设计者的意图。 成本和编程环境的限制对设计的均衡影响。 文化随机漂移，传统无非就是先入为主。   操作系统的风格元素  Unix &amp;ldquo;一切皆文件&amp;rdquo; 模型及在此基础上建立的管道概念</description>
    </item>
    
  </channel>
</rss>