<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unix on 淡淡忧愁</title>
    <link>https://timx.cn/categories/unix/</link>
    <description>Recent content in Unix on 淡淡忧愁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Aug 2018 15:08:36 +0800</lastBuildDate>
    
	<atom:link href="https://timx.cn/categories/unix/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unix编程艺术(三)</title>
      <link>https://timx.cn/post/unix_art_3/</link>
      <pubDate>Fri, 03 Aug 2018 15:08:36 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Unix编程艺术(二)</title>
      <link>https://timx.cn/post/unix_art_2/</link>
      <pubDate>Fri, 03 Aug 2018 10:20:36 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_2/</guid>
      <description> 模块性  保持清晰，保持简洁
Unix 重视模块化、正交性和紧凑性问题。
 封装与最佳模块大小  封装良好的模块不会过多的向外部暴露自身的细节，不会直接调用其他模块的实现码，也不会胡乱共享全局数据。 模块之间通过应用程序编写的接口（API）— 一组严密、定义良好的程序调用和数据结构来通信。 API在模块间扮演双重角色。在实现层面，作为模块间的滞塞点组织各自的内部细节被相邻模块知晓；在设计层面，API真正定义了整个体系。 模块最佳的物理行数在400-800行。  紧凑性  一个设计是否能装进人脑中的特性紧凑也不意味着“小巧”。即使一个设计良好的系统，对有经验的用户来说没什么特异之处、“一眼”就能看懂，但仍然可能包含很多部分。—Ken Arnold
 正交性  只做好一件事。纯粹的正交设计中，任何操作均无副作用：每个动作只改变一件事，不会影响其他。
 SPOT原则  Don&amp;rsquo;t Repeat Yourself !任何一个知识点在系统内都应当有一个唯一、明确、权威的表述。这个原则也叫“真理的单点性（Single Point of Truth）”或者SPOT原则。
 软件层次设计  自底向上从具体到抽象，从问题确定具体操作向上进行。
  自顶向下从抽象到具体，从最高层面描述整个项目的规格说明或应用逻辑开始，向下进行，直到各个具体操作。
 模块式编码 以下问题，有助于提高代码的模块性
  有多少全局变量  全局变量对模块化是毒药，很容易使各模块轻率、混乱的互相泄露信息  单个模块的大小是否在“最佳范围”内？  “不，很多都超过”，就可能产生长期的维护问题。 不知道自己或合作者的最佳范围是多少，那么保持最佳范围的下限-400行。  模块内的单个函数是不是太大了？  与其说这是一个行数问题，不如说是一个内部复杂度问题。如果不能用一句话来简单描述一个函数与其调用程序之间的约定，这个函数可能太大了.  代码是不是有内部API 可作为单元向其他人描述的函数调用集合数据结构集，并且每个单元都封装某一层次函数，不受其他代码的影响？ API的入口点是不是超过七个？有没有类有七个以上的方法？数据结构的成员是不是超过七个？ 整个项目中每个模块的入口点数量如何分布？是不是不均匀？   </description>
    </item>
    
    <item>
      <title>Unix编程艺术(一)</title>
      <link>https://timx.cn/post/unix_art_1/</link>
      <pubDate>Thu, 02 Aug 2018 16:47:52 +0800</pubDate>
      
      <guid>https://timx.cn/post/unix_art_1/</guid>
      <description>UNIX哲学  原则1：你无法判断程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急与胡乱这个地方改代码，除非你已经证实那儿就是瓶颈所在。 原则2：估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。 原则3：花哨的算法在n很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑原则2）。 原则4：花哨的算法比简单算法更容易出bug、更难实现。尽量使用简单的算法配合简单的数据结构。（拿不准就穷举） 原则5：数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法。 原则6：没有原则6。  从整体来说，可以概括为：  模块原则：使用简洁的接口拼合简单的部件。 清晰原则：清晰胜于机巧。 组合原则：设计时考虑拼接组合。 分离原则：策略同机制分离，接口同引擎分离。 简洁原则：设计要简洁，复杂度能低则低。 吝啬原则：除非确无它法，不要编写庞大的程序。 透明性原则：设计要可见，以便审查和调试。 健壮原则：健壮源于透明与简洁。 表示原则：把知识叠入数据以求逻辑质朴而健壮。 通俗原则：接口设计避免标新立异。 缄默原则：如果一个程序没什么好说的，就沉默。 补救原则：出现异常时，马上退出并给出足够错误信息。 经济原则：宁花机器一分，不花程序员一秒。 生成原则：避免手工hack，尽量编写程序去生成程序。 优化原则：雕琢前先要有原型，跑之前先学会走。 多样原则：决不相信所谓“不二法门”的断言。 扩展原则：设计着眼未来，未来总比预想来得快。  UNIX “KISS” 原则  Keep It Simple , Stupid ! 简单就是美 !
 应用哲学  只要可行，一切都应该做成与来源和目标无关的过滤器。 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）。 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）。 复杂的前端（用户界面）和后端应该泾渭分明。 如果可能，用C编写前，先用解释性语言搭建原型。 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。 宽收严发（对接收的东西要包容，对输出的东西要严格）。 过滤时，不需要丢弃的信息决不丢。 小就是美。在确保完成任务的基础上，程序功能尽可能少。  Unix哲学与其他哲学的比较 不同的操作系统相关的设计和编程风格可以追溯的三个源头  操作系统设计者的意图。 成本和编程环境的限制对设计的均衡影响。 文化随机漂移，传统无非就是先入为主。  操作系统的风格元素  Unix &amp;ldquo;一切皆文件&amp;rdquo; 模型及在此基础上建立的管道概念
  操作系统的同一理念</description>
    </item>
    
  </channel>
</rss>