<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构和算法 on 淡淡忧愁</title>
    <link>https://timx.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构和算法 on 淡淡忧愁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Oct 2018 14:35:43 +0800</lastBuildDate>
    
	<atom:link href="https://timx.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据结构和算法学习理解C语言实现(三)</title>
      <link>https://timx.cn/post/c_algorithm_3/</link>
      <pubDate>Tue, 30 Oct 2018 14:35:43 +0800</pubDate>
      
      <guid>https://timx.cn/post/c_algorithm_3/</guid>
      <description>树 “树”主要有根、干、枝、叶组成。在数据结构中树被引申为一个集合以及在该集合上定义的一种关系构成，包括根节点和若干课子树。
单个节点是一棵树，树根就是该节点本身。设T1,T2，···,Tk是数，它们的根节点分别为n1，n2，···，nk。如果用一个新节点n作为n1，n2，···，nk的父亲，得到一颗新树，节点n就是新树的根。称n1，n2，···，nk为一组兄弟节点，它们都是节点n的子节点，称n1，n2，···，nk为节点n的子树。由此可见数是由边连接起来的一系列节点，树的一个实例就是公司的组织机构图。
“树”需要满足如下两个条件
 有且仅有一个特定的称为根的节点 其余的节点可分为m个互不相交的有限集合T1，T2，···，Tm，其中，每个集合又都是一棵树（子树）。  树的相关概念
 节点的度：是指一个节点的子树个数。 树的度：一棵树中节点度的最大值。 叶子（终端节点）：度为0的节点 分支节点（非终端节点）：度不为0的节点。 内部节点：除根节点之外的分支节点。 孩子：将树中某个节点的子树的根称为这个节点的孩子。 双亲：某个节点的上层节点称为该节点的双亲。 兄弟：同一个双亲的孩子。 路径：如果在树中存在一个节点序列k1，k2，···，kj，使得ki是ki+1的双亲（1≤i&amp;lt;j）,称该节点序列是从k1到kj的一条路径 祖先：如果树中节点k到ks之间存在一条路径，则称k是ks的祖先。 子孙：ks是k的子孙。 层次：节点的层次是从根开始算起，第1层为根。 高度：树中节点的最大层次称为树的高度或深度。 有序数：将树中每个节点的各子树看成是从左到右有秩序的。 无序数：有序树之外的称为无序数。 森林：是n(n≥0)课互不想交的树的集合。  二叉树 二叉树是指每个节点最多有两个子树的有序树，通常将其两个子树的根分别称作“左子树”和“右子树”。
二叉树是节点的有限集，可以是空集，也可以是由一个根节点及两颗不相交的子树组成，通常将这两颗不想交的子树分别称作这个根的左子树和右子树。二叉树的特点。
 每个节点至多有两颗子树，即不存在度大于2的节点。 二叉树的子树有左右之分，次序不能颠倒。 二叉树的第i层最多有2的i-1次方个节点。 深度为k的二叉树最多有2的k次方-1个节点。 对任何一颗二叉树T，如果其终端节点树（即叶子节点树）为n0，度为2的节点树为n2，则n0=n2+1.  二叉树有5种基本形态
 空二叉树。 只有一个根节点的二叉树。 右子树为空的二叉树。 左子树为空的二叉树。 完全二叉树。  两种特殊的二叉树形态
 满二叉树：除了叶节点外，每一个节点都有左右子叶，并且叶节点都处在最底层的二叉树 完全二叉树：只有最下层的两层节点度小于2，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。  二叉树的性质
1） 在二叉树中，第i层的节点总数不超过2的i-1次方
2） 深度为h的二叉树最少有h个节点，最多有2的h次方-1个节点（h≥1）。
3） 对于任意一颗二叉树来说，如果叶节点树为n0，且度数为2的节点总数为n2，则n0=n2+1.
4） 有n个节点的完全二叉树的深度为int(log2底n) + 1.
5） 存在一个有n个节点的完全二叉树，如果各节点用顺序方式存储，则在节点之间有如下关系。
 如果i=1，则节点i为根，无父节点；如果i＞1，则父节点编号为trunc(n/2). 如果2i≤n，则其左儿子（即左子树的根节点）的编号为2i；如果2i&amp;gt;n,则无左儿子。 如果2i+1≤n，则其右儿子的节点编号为2i+1；如果2i+1＞n，则无右儿子。  6） 假设有n个节点，能构成h(n)种不同的二叉树，则h(n)为卡特兰数的第n项，h(n)=C(n,2n)/(n+1).</description>
    </item>
    
    <item>
      <title>数据结构和算法学习理解C语言实现(二)</title>
      <link>https://timx.cn/post/c_algorithm_2/</link>
      <pubDate>Thu, 25 Oct 2018 14:07:37 +0800</pubDate>
      
      <guid>https://timx.cn/post/c_algorithm_2/</guid>
      <description>线性表、队列和栈 在C语言数据之间一般存在3种疾病结构
 线性结构：数据元素间是一对一关系 树形结构：数据元素间是一对多关系 网状结构：数据元素间是多对多关系  线性表 线性表是一种最基本、最简单、最常用的数据结构。在实际应用中，线性表都是以栈、队列、字符串、数组等特殊线性表的形式来使用的。因为这些特殊线性表都具有自己的特性，所以掌握这些特殊线性表的特性，对于数据运算的可靠性和提高操作效率是至关重要的。
线性结构的特征
 集合中必存在唯一的“第一元素”和唯一的“最后元素”。 除最后元素之外，均有唯一的后继；除第一元素之外，均有唯一的前驱。  线性表的基本操作如下
 用Sernull(L):置空表。 用Length(L):求表长度和表中各元素个数。 Get(L, i):获取表中第i个元素（1&amp;lt;=i&amp;lt;=n） Prior(L, i):获取i的前驱元素。 Next(L, i):获取i的后继元素。 Locate(L, x):返回指定元素在表中的位置。 Insert(L, i, x):插入新元素。 Delete(L,x):删除已存在元素。 Empty(L):判断表是否为空。  线性表的结构特点
 均匀性：虽然不同数据表的数据元素是各种各样的，但同一线性表的各数据元素必须有相同的类型和长度。 有序性：各数据元素在线性表中的位置只取决于他们的序。数据元素之前的相对位置是由线性的，即存在唯一的“第一个”和“最后一个”数据元素，除了第一个和最后一个外，其他元素前面只有一个数据元素直接前驱。  在实际应用中，有两种实现线性表数据元素存储功能的方法，分别是顺序存储结构和链式存储结构。
顺序表操作的功能有以下几种
1）计算顺序表的长度
数组的最小索引是0，顺序表的长度就是数组中最后一个元素的索引last加1.
2） 清空操作
清空操作是指清除顺序表中的数据元素，最终目的是使顺序表为空，此时last等于-1.
3） 判断线性表是否为空
当顺序表的last为-1时表示顺序表为空，此时会返回true，否则返回false表示不为空。
4） 判断顺序表是否为满
当顺序表为满时last值等于maxsize-1，此时会返回true，如果不为满则返回false。
5） 附加操作
在顺序表没有满的情况下进行附加操作，在表的末端添加一个新元素，然后使顺序表的last加1.
6） 插入操作
在顺序表中插入数据的方法非常简单，只需要在顺序表的第i个位置插入一个值为item的新元素即可。
在顺序表插入一个新数据元素的基本步骤如下。
 判断顺序表的状态，判断是否已满和插入的位置是否正确，当表满或插入的位置不正确时不能插入。 当表未满直插入的位置正确时，将an~ai依次向后移动，为新的数据元素空出位置。在算法中用循环来实现。 将新的数据元素插入到空出的第i个位置上 修改last值以修改表长，使其仍指向顺序表的最后一个数据元素  7） 删除操作
可以删除顺序表中的第i个数据元素
在顺序表中删除一个数据元素的基本流程如下。
 判断顺序表是否为空，判断删除的位置是否正确，当为空或删除的位置不正确时不能删除 如果表为空和删除的位置正确，则将ai+1~an依次向前移动，在算法中用循环来实现移动功能 修改last值以修改表长，使它仍指向顺序表的最后一个数据元素。  8） 获取表元</description>
    </item>
    
    <item>
      <title>数据结构和算法学习理解C语言实现(一)</title>
      <link>https://timx.cn/post/c_algorithm_1/</link>
      <pubDate>Thu, 18 Oct 2018 13:51:03 +0800</pubDate>
      
      <guid>https://timx.cn/post/c_algorithm_1/</guid>
      <description>常用的算法思想 枚举算法思想 将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适。在C语言中，枚举算法一般使用while循环实现。使用枚举算法解题的基本思路如下。
 确定枚举对象、枚举范围和判定条件。 逐一列举可能的解，验证每个解是否是问题的解。  枚举算法一般按照如下3个步骤进行。
 题解的可能范围，不能遗漏任何一个真正解，也要避免有重复。 判断是否是真正解的方法。 使可能解的范围降至最小，以便提高解决问题的效率。  问题:公鸡每只5元，母鸡每只3元，小鸡3只一元。用100元钱买100只鸡，问公鸡、母鸡、小鸡各多少？
#include &amp;lt;stdio.h&amp;gt; int main() { int x,y,z;//x:公鸡，y:母鸡，z:小鸡 for(x=0;x&amp;lt;=20;x++) { for(y=0;y&amp;lt;=33;y++) { z=100-x-y; if(z%3==0 &amp;amp;&amp;amp; x*5+y*3+z/3==100) printf(&amp;quot;公鸡：%d,母鸡：%d,小鸡：%d\n&amp;quot;, x,y,z); } } getchar(); return 0; }  输出 +++++++++++++++++++++++ 公鸡：0,母鸡：25,小鸡：75 公鸡：4,母鸡：18,小鸡：78 公鸡：8,母鸡：11,小鸡：81 公鸡：12,母鸡：4,小鸡：84 +++++++++++++++++++++++  递推算法思想 递推算法可以不断利用已有的信息推导出新的东西，在日常应用有两种递推算法。
 顺推法：从已知条件出发，逐步推算出要解决问题的方法。例如斐波那契数列就可以通过顺推法不断递推算出新的数据。 逆推法：从已知的结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。  问题：斐波那契数列以兔子繁殖为例子而引入，所以又称为“兔子数列”。兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生一对小兔子。如果所以兔子都不死，那么一年之后可以繁殖多少对兔子
算法分析：
 第一个月小兔子没有繁殖能力，所以还是一对。 2个月后，一对小兔子生下一对新的小兔子，所以共有两对兔子。 3个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是3对。  月数与兔子对数关系表
   - - - - - - - - - -     月数： 1 2 3 4 5 6 7 8 &amp;hellip;   对数： 1 1 2 3 5 8 13 21     对数：1,1,2,3,5,8··· ···构成了一个数列，这个数列有个十分明显的特点：前面相邻两项之和，构成了后一项。</description>
    </item>
    
  </channel>
</rss>