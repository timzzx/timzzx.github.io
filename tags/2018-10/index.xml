<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2018 10 on 淡淡忧愁</title>
    <link>https://timx.cn/tags/2018-10/</link>
    <description>Recent content in 2018 10 on 淡淡忧愁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Oct 2018 14:07:37 +0800</lastBuildDate>
    
	<atom:link href="https://timx.cn/tags/2018-10/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据结构和算法学习理解C语言实现(二)</title>
      <link>https://timx.cn/post/c_algorithm_2/</link>
      <pubDate>Thu, 25 Oct 2018 14:07:37 +0800</pubDate>
      
      <guid>https://timx.cn/post/c_algorithm_2/</guid>
      <description>线性表、队列和栈 在C语言数据之间一般存在3种疾病结构
 线性结构：数据元素间是一对一关系 树形结构：数据元素间是一对多关系 网状结构：数据元素间是多对多关系  线性表 线性表是一种最基本、最简单、最常用的数据结构。在实际应用中，线性表都是以栈、队列、字符串、数组等特殊线性表的形式来使用的。因为这些特殊线性表都具有自己的特性，所以掌握这些特殊线性表的特性，对于数据运算的可靠性和提高操作效率是至关重要的。
线性结构的特征
 集合中必存在唯一的“第一元素”和唯一的“最后元素”。 除最后元素之外，均有唯一的后继；除第一元素之外，均有唯一的前驱。  线性表的基本操作如下
 用Sernull(L):置空表。 用Length(L):求表长度和表中各元素个数。 Get(L, i):获取表中第i个元素（1&amp;lt;=i&amp;lt;=n） Prior(L, i):获取i的前驱元素。 Next(L, i):获取i的后继元素。 Locate(L, x):返回指定元素在表中的位置。 Insert(L, i, x):插入新元素。 Delete(L,x):删除已存在元素。 Empty(L):判断表是否为空。  线性表的结构特点
 均匀性：虽然不同数据表的数据元素是各种各样的，但同一线性表的各数据元素必须有相同的类型和长度。 有序性：各数据元素在线性表中的位置只取决于他们的序。数据元素之前的相对位置是由线性的，即存在唯一的“第一个”和“最后一个”数据元素，除了第一个和最后一个外，其他元素前面只有一个数据元素直接前驱。  在实际应用中，有两种实现线性表数据元素存储功能的方法，分别是顺序存储结构和链式存储结构。
顺序表操作的功能有以下几种
1）计算顺序表的长度
数组的最小索引是0，顺序表的长度就是数组中最后一个元素的索引last加1.
2） 清空操作
清空操作是指清除顺序表中的数据元素，最终目的是使顺序表为空，此时last等于-1.
3） 判断线性表是否为空
当顺序表的last为-1时表示顺序表为空，此时会返回true，否则返回false表示不为空。
4） 判断顺序表是否为满
当顺序表为满时last值等于maxsize-1，此时会返回true，如果不为满则返回false。
5） 附加操作
在顺序表没有满的情况下进行附加操作，在表的末端添加一个新元素，然后使顺序表的last加1.
6） 插入操作
在顺序表中插入数据的方法非常简单，只需要在顺序表的第i个位置插入一个值为item的新元素即可。
在顺序表插入一个新数据元素的基本步骤如下。
 判断顺序表的状态，判断是否已满和插入的位置是否正确，当表满或插入的位置不正确时不能插入。 当表未满直插入的位置正确时，将an~ai依次向后移动，为新的数据元素空出位置。在算法中用循环来实现。 将新的数据元素插入到空出的第i个位置上 修改last值以修改表长，使其仍指向顺序表的最后一个数据元素  7） 删除操作
可以删除顺序表中的第i个数据元素
在顺序表中删除一个数据元素的基本流程如下。
 判断顺序表是否为空，判断删除的位置是否正确，当为空或删除的位置不正确时不能删除 如果表为空和删除的位置正确，则将ai+1~an依次向前移动，在算法中用循环来实现移动功能 修改last值以修改表长，使它仍指向顺序表的最后一个数据元素。  8） 获取表元</description>
    </item>
    
    <item>
      <title>数据结构和算法学习理解C语言实现(一)</title>
      <link>https://timx.cn/post/c_algorithm_1/</link>
      <pubDate>Thu, 18 Oct 2018 13:51:03 +0800</pubDate>
      
      <guid>https://timx.cn/post/c_algorithm_1/</guid>
      <description>常用的算法思想 枚举算法思想 将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适。在C语言中，枚举算法一般使用while循环实现。使用枚举算法解题的基本思路如下。
 确定枚举对象、枚举范围和判定条件。 逐一列举可能的解，验证每个解是否是问题的解。  枚举算法一般按照如下3个步骤进行。
 题解的可能范围，不能遗漏任何一个真正解，也要避免有重复。 判断是否是真正解的方法。 使可能解的范围降至最小，以便提高解决问题的效率。  问题:公鸡每只5元，母鸡每只3元，小鸡3只一元。用100元钱买100只鸡，问公鸡、母鸡、小鸡各多少？
#include &amp;lt;stdio.h&amp;gt; int main() { int x,y,z;//x:公鸡，y:母鸡，z:小鸡 for(x=0;x&amp;lt;=20;x++) { for(y=0;y&amp;lt;=33;y++) { z=100-x-y; if(z%3==0 &amp;amp;&amp;amp; x*5+y*3+z/3==100) printf(&amp;quot;公鸡：%d,母鸡：%d,小鸡：%d\n&amp;quot;, x,y,z); } } getchar(); return 0; }  输出 +++++++++++++++++++++++ 公鸡：0,母鸡：25,小鸡：75 公鸡：4,母鸡：18,小鸡：78 公鸡：8,母鸡：11,小鸡：81 公鸡：12,母鸡：4,小鸡：84 +++++++++++++++++++++++  递推算法思想 递推算法可以不断利用已有的信息推导出新的东西，在日常应用有两种递推算法。
 顺推法：从已知条件出发，逐步推算出要解决问题的方法。例如斐波那契数列就可以通过顺推法不断递推算出新的数据。 逆推法：从已知的结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。  问题：斐波那契数列以兔子繁殖为例子而引入，所以又称为“兔子数列”。兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生一对小兔子。如果所以兔子都不死，那么一年之后可以繁殖多少对兔子
算法分析：
 第一个月小兔子没有繁殖能力，所以还是一对。 2个月后，一对小兔子生下一对新的小兔子，所以共有两对兔子。 3个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是3对。  月数与兔子对数关系表
   - - - - - - - - - -     月数： 1 2 3 4 5 6 7 8 &amp;hellip;   对数： 1 1 2 3 5 8 13 21     对数：1,1,2,3,5,8··· ···构成了一个数列，这个数列有个十分明显的特点：前面相邻两项之和，构成了后一项。</description>
    </item>
    
    <item>
      <title>C指针知识点收集</title>
      <link>https://timx.cn/post/c_point/</link>
      <pubDate>Thu, 11 Oct 2018 14:25:05 +0800</pubDate>
      
      <guid>https://timx.cn/post/c_point/</guid>
      <description>C指针知识点收集 1.C使用内存  静态/全局内存（静态声明的变量，全局变量也使用这部分内存。静态变量的作用域则局限在定义它们的函数内部） 自动内存（函数内部声明，只在函数被调用时才创建，只在函数内部调用。） 动态内存（内存分配在堆上，可以根据需要释放。）  2.C的动态内存分配实际上就是通过使用指针实现的。malloc和free函数分别用来分配和释放动态内存。动态内存分配可以实现变长数组和数据结构（如链表和队列）。 3.声明整数和一个整数指针 int num; int *pi;  4.星号两边的空白符无关紧要，下面声明都是等价的 int* pi; int * pi; int *pi; int*pi;  5.阅读声明 const int *pci;  倒过来读
1.pci是一个变量 const int *pci;
2.pci是一个指针变量 const int *pci;
3.pci是一个指向整数的指针变量 const int *pci;
4.pci是一指向整数常量的指针个变量 const int *pci;
6.地址操作符&amp;amp;会返回操作数的地址。可以用这个操作符初始化pi指针 num = 0; pi = &amp;amp;num;  还可以这样初始化；
int num; int *pi = &amp;amp;num;  7.虚拟内存和指针。程序使用的地址是虚拟地址。操作系统会在需要时把虚拟地址映射为物理内存地址。 8.用间接引用操作符解引指针。间接引用操作符（*）返回指针变量指向的值，一般称为解引指针 9.指向函数的指针 函数可以声明为指向函数。函数没有返回值。指针的名字叫foo
void (*foo)();  10.</description>
    </item>
    
  </channel>
</rss>